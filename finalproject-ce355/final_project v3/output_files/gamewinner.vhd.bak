library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.tank_const.all;
use work.game_library.all;

entity bullet_control is
	port(
		clk, rst_n, we  : in std_logic;
		
		winner			    : out std_logic;
		score              : out integer;
		--no_winner          : out std_logic;
		collision_hit      : in std_logic
		
		);
end entity bullet_control;

architecture fsm of bullet_control is

	-- Define the states, including 'done'
	type state_type is (start, scored, check_winner, win, lose, done);
	signal current_state, next_state : state_type;

begin

	-- Asynchronous Reset and Synchronous State Update
	process(clk, rst_n)
		begin
			if rst_n = '1' then
				current_state <= start;
			elsif (rising_edge(clk)) then
				current_state <= next_state;
			end if;
	end process;
	
	-- Next State and Output Logic
	process(current_state, we, bullet_pos_in, fire, bullet_fired_in, direction, speed, tank_pos_in)
	begin
		-- Default assignments to avoid latches
		next_state <= current_state;
		winner <= '0';
		score <= 0;
		
		case current_state is
		
			when start =>
				if collision_hit = '1' then
					next_state <= scored;
				else
					next_state <= start;
				end if;
				
			when scored =>
				score <= score + 1;
			   next_state <= check_winner;
				
			when check_winner =>
				if score >= 3 then
				   next_state <= winner;
				else
					next_state <= start;
				end if;
			
			when winner =>
				next_state <= done;
			   winner <= '1';
			
			when done =>
				-- Maintain the current state values explicitly
				next_state <= done;
				winner <= '1';
			
			when others =>
				-- Explicitly assign defaults in case of unexpected state
				next_state <= start;
				bullet_disp <= '1';
				bullet_pos_out(0) <= 300;
				bullet_pos_out(1) <= 300;
				bullet_fired_out <= '0';
				
			end case;
	end process;

end architecture fsm;